using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Text;

namespace Messaging
{
    [ContractClass(typeof(MessageBusContract))]
    public interface IMessageBus : IDisposable
    {
        /// <summary>
        /// Gets the local queue endpoint
        /// </summary>
        QueueEndpoint LocalEndpoint { get; }

        /// <summary>
        /// True if the messagebus is currently listening for messages. Otherwise false.
        /// </summary>
        bool IsRunning { get; }

        MessageHandlers MessageHandlers { get; }

        /// <summary>
        /// Sends a message to all target endpoints registered for that type of message.
        /// </summary>
        /// <param name="message">Message to send</param>
        void Send(object message);

        /// <summary>
        /// Sends a message to the specified endpoint
        /// </summary>
        /// <typeparam name="TMessage">Type of message to send</typeparam>
        /// <param name="message">The message to send</param>
        /// <param name="targetEndpoint">Endpoint to send the message to</param>
        void Send(object message, QueueEndpoint targetEndpoint);

        /// <summary>
        /// Registers a target endpoint as a recipient of messages of type <typeparamref name="TMessage"/>
        /// </summary>
        /// <typeparam name="TMessage">Type of messages to recieve</typeparam>
        /// <param name="targetEndpoint">Target endpoint that should recieve messages</param>
        void RegisterTargetEndpoint<TMessage>(QueueEndpoint targetEndpoint);

        /// <summary>
        /// Deregisters a target endpoint as no longer being a recipient of message of type <typeparamref name="TMessage"/>
        /// </summary>
        /// <typeparam name="TMessage">Type of messages to no longer recieve</typeparam>
        /// <param name="targetEndpoint">Target endpoint that should no longer recieve messages.</param>
        void DeregisterTargetEndpoint<TMessage>(QueueEndpoint targetEndpoint);

        ///// <summary>
        ///// Registers a message handler for messages of type <typeparamref name="TMessage"/>
        ///// </summary>
        ///// <typeparam name="TMessage">Type of messages that this handler can handle</typeparam>
        ///// <param name="handler"></param>
        //void RegisterMessageHandler<TMessage>(Action<TMessage> handler);

        ///// <summary>
        ///// Registers a factory that generates replies of type <typeparamref name="TReply"/>
        ///// when given a message of type <typeparamref name="TMessage"/>
        ///// </summary>
        ///// <typeparam name="TMessage">Type of message to reply to</typeparam>
        ///// <typeparam name="TReply">Type of reply generated by factory</typeparam>
        ///// <param name="replyGenerator"></param>
        //void RegisterReplyGenerator<TMessage>(Func<TMessage, object> replyGenerator);

        /// <summary>
        /// Starts listening on the local queue
        /// </summary>
        void Start();

        /// <summary>
        /// Stops listening on the local queue
        /// </summary>
        void Stop();
    }

    //public abstract class MessageBus : IMessageBus
    //{
    //    protected readonly TargetEndpoints _targetEndpoints = new TargetEndpoints();

    //    protected readonly MessageHandlers _messageHandlers = new MessageHandlers();

    //    protected readonly ReplyGenerators _replyGenerator = new ReplyGenerators();

    //    protected MessageBus(QueueEndpoint localEndpoint)
    //    {
    //        LocalEndpoint = localEndpoint;
    //    }

    //    public QueueEndpoint LocalEndpoint { get; set; }

    //    public bool IsRunning { get; private set; }

    //    public UnhandledMessagesPolicy UnhandledMessagesPolicy { get; set; }

    //    public void Send(object message)
    //    {
    //        var messageType = message.GetType();
    //        foreach(var endpoint in _targetEndpoints.GetFor(messageType))
    //            SendImpl(message, endpoint);
    //    }

    //    public void Send(object message, QueueEndpoint targetEndpoint)
    //    {
    //        SendImpl(message, targetEndpoint);
    //    }

    //    protected abstract void SendImpl<TMessage>(TMessage message, QueueEndpoint endpoint);

    //    public void RegisterTargetEndpoint<TMessage>(QueueEndpoint targetEndpoint)
    //    {
    //        _targetEndpoints.AddFor<TMessage>(targetEndpoint);
    //    }

    //    public void DeregisterTargetEndpoint<TMessage>(QueueEndpoint targetEndpoint)
    //    {
    //        _targetEndpoints.RemoveFor<TMessage>(targetEndpoint);
    //    }

    //    public void RegisterMessageHandler<TMessage>(Action<TMessage> handler)
    //    {
    //        _messageHandlers.Add(handler);
    //    }

    //    public void DeregisterMessageHandler<TMessage>(Action<TMessage> handler)
    //    {
    //        _messageHandlers.Remove(handler);
    //    }

    //    public void RegisterReplyGenerator<TMessage>(Func<TMessage, object> replyGenerator)
    //    {
    //        _replyGenerator.AddFor<TMessage>(replyGenerator);
    //    }

    //    public void Start()
    //    {
    //        if (IsRunning)
    //            return;

    //        try
    //        {
    //            StartImpl();
    //            IsRunning = true;
    //        }
    //        catch (Exception ex)
    //        {
    //            throw new UnableToStartMessageBusException("Failed to start the message bus", ex);
    //        }
    //    }

    //    protected abstract void StartImpl();

    //    public void Stop()
    //    {
    //        if(!IsRunning)
    //            return;

    //        StopImpl();
    //        IsRunning = false;
    //    }

    //    protected abstract void StopImpl();

    //    protected void HandleMessage(object message)
    //    {
    //        if (ReferenceEquals(message, null)) return;

    //        try
    //        {
    //            HandleMessageImpl((dynamic)message);
    //        }
    //        catch
    //        {

    //        }
    //    }

    //    private void HandleMessageImpl<TMessage>(TMessage message)
    //    {
    //        var handlers = _messageHandlers.For<TMessage>();
    //        if (!handlers.Any())
    //            return; // TODO: Should be doing something here.

    //        foreach (var handler in _messageHandlers.For<TMessage>())
    //        {
    //            handler(message);
    //        }
    //    }

    //    public void Dispose()
    //    {
    //        Dispose(true);
    //        GC.SuppressFinalize(this);
    //    }

    //    protected virtual void Dispose(bool disposing) { }

    //    protected class MessageHandlers
    //    {
    //        private readonly List<MessageHandlerDescriptor> _descriptors = new List<MessageHandlerDescriptor>();

    //        public void Add<TMessage>(Action<TMessage> handler)
    //        {
    //            var newDescriptor = new MessageHandlerDescriptor(typeof(TMessage), new Action<object>(o => handler((TMessage)o)));
    //            if(!_descriptors.Contains(newDescriptor))
    //                _descriptors.Add(newDescriptor);
    //        }

    //        public IEnumerable<Action<object>> For<TMessage>()
    //        {
    //            var messageType = typeof(TMessage);

    //            return _descriptors.Where(d => d.MessageType.IsAssignableFrom(messageType))
    //                               .Select(d => d.MessageHandler);
    //        }

    //        public void Remove<TMessage>(Action<TMessage> handler)
    //        {
    //            _descriptors.RemoveAll(d => d.MessageType == typeof(TMessage) && (d.MessageHandler as Action<TMessage>) == handler);
    //        }
    //    }

    //    protected class TargetEndpoints
    //    {
    //        private readonly List<TargetEndpointDescriptor> _descriptors = new List<TargetEndpointDescriptor>();

    //        public void AddFor<TMessage>(QueueEndpoint endpoint)
    //        {
    //            var newDescriptor = new TargetEndpointDescriptor(typeof(TMessage), endpoint);
    //            if (!_descriptors.Contains(newDescriptor))
    //                _descriptors.Add(newDescriptor);
    //        }

    //        public void RemoveFor<TMessage>(QueueEndpoint endpoint)
    //        {
    //            var messageType = typeof(TMessage);
    //            _descriptors.RemoveAll(d => d.MessageType == messageType && d.Endpoint == endpoint);
    //        }

    //        public IEnumerable<QueueEndpoint> GetFor(Type messageType)
    //        {
    //            lock (_descriptors)
    //            {
    //                return _descriptors.Where(d => d.MessageType.IsAssignableFrom(messageType)).Select(d => d.Endpoint).ToList();
    //            }
    //        }
    //    }

    //    protected class ReplyGenerators
    //    {
    //        private readonly ConcurrentDictionary<RuntimeTypeHandle, Delegate> _replyGenerators =
    //            new ConcurrentDictionary<RuntimeTypeHandle, Delegate>();

    //        public void AddFor<TMessage>(Func<TMessage, object> replyGenerator)
    //        {
    //            _replyGenerators[typeof(TMessage).TypeHandle] = replyGenerator;
    //        }

    //        public object GenerateReplyTo<TMessage>(TMessage message)
    //        {
    //            var generator = For<TMessage>();
    //            if(generator != null)
    //                return For<TMessage>().Invoke(message);

    //            return null;
    //        }

    //        public void RemoveFor<TMessage>()
    //        {
    //            Delegate removedObject;
    //            _replyGenerators.TryRemove(typeof(TMessage).TypeHandle, out removedObject);
    //        }

    //        public Func<TMessage, object> For<TMessage>()
    //        {
    //            var typeHandle = typeof(TMessage).TypeHandle;

    //            if (_replyGenerators.ContainsKey(typeHandle))
    //                return (Func<TMessage, object>)_replyGenerators[typeHandle];

    //            return null;
    //        }
    //    }
    //}

    [Serializable]
    public struct QueueEndpoint
    {
        public readonly string MachineName;

        public readonly string QueueName;

        public QueueEndpoint(string machineName, string queueName)
        {
            MachineName =
                machineName.IsLocalhost() ?
                Environment.MachineName :
                machineName;

            QueueName = queueName;
        }

        public override bool Equals(object obj)
        {
            if(Object.ReferenceEquals(obj, null))
                return false;
            if(Object.ReferenceEquals(this, obj))
                return true;

            if(obj is QueueEndpoint)
                return Equals((QueueEndpoint)obj);

            return false;
        }

        public override int GetHashCode()
        {
            unchecked
            {
                return MachineName.GetHashCode() * 32 + QueueName.GetHashCode();
            }
            
        }

        private bool Equals(QueueEndpoint other)
        {
            return this.MachineName == other.MachineName && this.QueueName == other.QueueName;
        }

        public static bool operator ==(QueueEndpoint left, QueueEndpoint right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(QueueEndpoint left, QueueEndpoint right)
        {
            return !Equals(left, right);
        }
    }

    internal class TargetEndpointDescriptor : IEquatable<TargetEndpointDescriptor>
    {
        public Type MessageType { get; private set; }
        public QueueEndpoint Endpoint { get; private set; }

        public TargetEndpointDescriptor(Type messageType, QueueEndpoint endpoint)
        {
            MessageType = messageType;
            Endpoint = endpoint;
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(obj, null))
                return false;
            if (ReferenceEquals(this, obj))
                return true;

            return Equals(obj as TargetEndpointDescriptor);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                return MessageType.GetHashCode() * 31 + Endpoint.GetHashCode();
            }
            
        }

        public bool Equals(TargetEndpointDescriptor other)
        {
            if(other == null)
                return false;

            return this.MessageType == other.MessageType && this.Endpoint == other.Endpoint;
        }
    }

    internal class MessageHandlerDescriptor : IEquatable<MessageHandlerDescriptor>
    {
        public Type MessageType { get; private set; }

        public Action<object> MessageHandler { get; private set; }

        public MessageHandlerDescriptor(Type messageType, Action<object> messageHandler)
        {
            MessageType = messageType;
            MessageHandler = messageHandler;
        }

        public bool Equals(MessageHandlerDescriptor other)
        {
            if(other == null)
                return false;

            return this.MessageType == other.MessageType && this.MessageHandler == other.MessageHandler;
        }
    }

    internal static class StringExtension
    {
        public static bool IsLocalhost(this string machineName)
        {
            return String.IsNullOrWhiteSpace(machineName) ||
                   machineName.Equals(".", StringComparison.InvariantCultureIgnoreCase) ||
                   machineName.Equals("localhost", StringComparison.InvariantCultureIgnoreCase);
        }
    }

    public enum UnhandledMessagesPolicy
    {
        Leave = 1,
        Requeue = 2,
        LogError = 3,
        Discard = 4
    }

    [ContractClassFor(typeof(IMessageBus))]
    public class MessageBusContract : IMessageBus
    {
        public QueueEndpoint LocalEndpoint
        {
            get { throw new NotImplementedException(); }
        }

        public bool IsRunning
        {
            get { throw new NotImplementedException(); }
        }

        public MessageHandlers MessageHandlers { get { throw new NotImplementedException(); } }

        public void Send(object message)
        {
            Contract.Requires(message != null, "message cannot be null");
        }

        public void Send(object message, QueueEndpoint targetEndpoint)
        {
            Contract.Requires(message != null, "message cannot be null");
        }

        public void RegisterTargetEndpoint<TMessage>(QueueEndpoint targetEndpoint)
        {
            throw new NotImplementedException();
        }

        public void DeregisterTargetEndpoint<TMessage>(QueueEndpoint targetEndpoint)
        {
            throw new NotImplementedException();
        }

        public void RegisterMessageHandler<TMessage>(Action<TMessage> handler)
        {
            Contract.Requires<ArgumentNullException>(handler != null, "handler cannot be null");
        }

        public void RegisterReplyGenerator<TMessage>(Func<TMessage,object> replyGenerator)
        {
            Contract.Requires<ArgumentNullException>(replyGenerator != null, "replyGenerator cannot be null");
        }

        public void Start()
        {
            throw new NotImplementedException();
        }

        public void Stop()
        {
            throw new NotImplementedException();
        }

        public void Dispose()
        {
            throw new NotImplementedException();
        }
    }
}
